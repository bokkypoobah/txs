<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Txs</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Txs (c) Bok Consulting Pty Ltd 2022" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.6.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/ZombieBaby_001_gp2_3871_8601_10786.gif" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">Txs</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <!-- <b-avatar v-if="coinbase && coinbase != ensOrAddress(coinbase)" rounded variant="light" size="2.5rem" :src="ensOrAddress(coinbase)"></b-avatar> -->
            <b-button size="sm" variant="outline-primary" class="ml-1" @click="doIt('syncUmswaps')" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? ensOrAddress(coinbase) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Revoke permissions when not required, at this early stage.
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension, connect to the Ethereum mainnet and refresh this page. Then click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-card-body class="m-0 px-1 py-0 pt-1">

            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="showImport" variant="link" v-b-popover.hover.top="'Show import dialog'"><span v-if="showImport"><b-icon-plus-square-fill shift-v="+1" font-scale="1.0"></b-icon-plus-square-fill></span><span v-else><b-icon-plus-square shift-v="+1" font-scale="1.0"></b-icon-plus-square></span></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null" @click="processIt('retrieveData')" variant="primary" style="min-width: 40px;" v-b-popover.hover.top="'Retrieve tx data via web3. Import your tx hashes if you have not already done so'"><b-icon-cloud-download shift-v="+1" font-scale="0.9"></b-icon-cloud-download></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="txs.period" :options="txsPeriodOptions" v-b-popover.hover.top="'Period'"></b-form-select>
              </div>
              <div class="mt-0">
                <b-button-group>
                  <b-button size="sm" @click="toggleTxs(pagedFilteredSortedTxs)" variant="link" v-b-popover.hover.top="'Toggle selection for all from current page'"><b-icon-check shift-v="+1" font-scale="1.0"></b-icon-check></b-button>
                  <b-button size="sm" @click="toggleTxs(filteredSortedTxs)" variant="link" v-b-popover.hover.top="'Toggle selection for all from all pages'"><b-icon-check-all shift-v="+1" font-scale="1.0"></b-icon-check-all></b-button>
                </b-button-group>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null" @click="processIt('compute')" variant="link" v-b-popover.hover.top="'Perform computations on selected items'"><b-icon-caret-right-square shift-v="+1" font-scale="0.9"></b-icon-caret-right-square></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-1" style="width: 200px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="txs.sortOption" :options="txsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <font size="-2" v-b-popover.hover.top="'# txs'">{{ filteredSortedTxs.length }}</font>
              </div>
              <div class="mt-0 pr-1">
                <b-pagination size="sm" v-model="txs.currentPage" :total-rows="filteredSortedTxs.length" :per-page="txs.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="txs.pageSize" :options="txsPageSizes" v-b-popover.hover.top="'Transactions page size'"></b-form-select>
              </div>
            </div>

            <b-card v-if="showImport" no-body no-header bg-variant="light" class="m-1 p-1 w-75">
              <b-card-body class="m-1 p-1">
                <b-form-group label-cols-lg="2" label="Import Hashes" label-size="md" label-class="font-weight-bold pt-0" class="mb-0">
                  <b-form-group label="Hashes:" label-for="importhashes-hashes" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Export from Etherscan.io and paste in the column of Ethereum tx hashes" class="mx-0 my-1 p-0">
                    <b-form-textarea size="sm" id="importhashes-hashes" v-model.trim="importTxHashes.hashes" rows="1" max-rows="5" class="w-100"></b-form-textarea>
                  </b-form-group>
                  <b-form-group label="" label-for="importhashes-submit" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Tx hashes will be saved into your local browser storage" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="importhashes-submit" :disabled="importTxHashes.hashes == null || importTxHashes.hashes.length == 0" @click="processIt('importHashes')" variant="warning">Import</b-button>
                  </b-form-group>
                </b-form-group>
              </b-card-body>
            </b-card>

            <b-table small fixed striped selectable responsive hover :fields="txsFields" :items="pagedFilteredSortedTxs" head-variant="light" class="m-0 mt-1">
              <template #cell(number)="data">
                <b-form-checkbox size="sm" :checked="selectedTxs[data.item.txHash] ? 1 : 0" value="1" @change="toggleTx(data.item.txHash)">
                  {{ parseInt(data.index) + ((txs.currentPage - 1) * txs.pageSize) + 1 }}
                </b-form-checkbox>
              </template>
              <template #cell(timestamp)="data">
                <b-link :href="'https://etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'View in Etherscan.io'" target="_blank">{{ formatTimestamp(data.item.timestamp) }}</b-link>
              </template>
              <template #cell(from)="data">
                <b-link :href="'https://etherscan.io/address/' + data.item.from" v-b-popover.hover.bottom="'View address in Etherscan.io'" target="_blank">
                  {{ ensOrAddress(data.item.from) }}
                </b-link>
              </template>
              <template #cell(to)="data">
                <b-link :href="'https://etherscan.io/address/' + data.item.to" v-b-popover.hover.bottom="'View address in Etherscan.io'" target="_blank">
                  {{ ensOrAddress(data.item.to) }}
                </b-link>
              </template>
              <template #cell(txHash)="data">
                <b-link :href="'https://etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'View tx in Etherscan.io'" target="_blank">
                  {{ data.item.txHash.substring(0, 16) }}
                </b-link>
              </template>
            </b-table>
          </b-card-body>
        </b-card>
        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <b-card-text class="text-right">
            gm, and enjoy! <i>Txs</i> &copy; Bok Consulting Pty Ltd 2022.
          </b-card-text>
        </b-card no-header>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          coinbase: null,
          txs: {
            period: 'fym5', // TODO: null,
            currentPage: 1,
            pageSize: 100,
            sortOption: 'timeasc',
          },
          showImport: false,
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },
          importTxHashes: {
            hashes: null,
          },
          txHashes: {},
          ensMap: {},
          selectedTxs: {},

          txsSortOptions: [
            { value: 'timeasc', text: '▲ Time' },
            { value: 'timedsc', text: '▼ Time' },
          ],
          txsPageSizes: [
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          txsFields: [
            { key: 'number', label: '#', thStyle: 'width: 5%;', thClass: 'text-center', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'Timestamp', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'from', label: 'From', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'to', label: 'To', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'blah', label: 'Blah', thStyle: 'width: 35%;', tdClass: 'text-truncate' },
            { key: 'txHash', label: 'Transactions', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            // { key: 'collection', label: '', thStyle: 'width: 52%;', tdClass: 'text-truncate' },
            // { key: 'pools', label: '# Pools', thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
            // { key: 'balance', label: '∑ Balance', thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            // { key: 'nftsInPool', label: '∑ NFTs', thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
          ],

          db: {
            name: "txs089",
            version: 1,
            schemaDefinition: {
              cache: '&objectName',
              // collection: '&address',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          txsPeriodOptions() {
            const results = [];
            results.push({ value: null, text: "(select period)", data: null });

            const startMonth = "Jul";
            const now = moment();
            let currentStartPeriod = moment(now).month(startMonth).startOf('month');
            if (currentStartPeriod > now) {
              currentStartPeriod = currentStartPeriod.subtract(1, 'year');
            }
            for (let year = 0; year < 7; year++) {
              const startPeriod = moment(currentStartPeriod).subtract(year, 'year');
              const endPeriod = moment(startPeriod).add(1, 'year').subtract(1, 'second');
              results.push({ value: "fym" + year, text: startPeriod.format('MMM DD YYYY') + " to " + endPeriod.format('MMM DD YYYY'), data: { startPeriod, endPeriod } });
            }
            results.push({ value: "nodata", text: "(tx hashes with no data)", data: null });
            return results;
          },
          filteredTxs() {
            const results = this.collectionsSortOption ? [] : [];
            let startPeriod = null;
            let endPeriod = null;
            if (this.txs.period != null && this.txs.period != "nodata") {
              const periodRecords = this.txsPeriodOptions.filter(e => e.value == this.txs.period);
              startPeriod = periodRecords[0].data.startPeriod;
              endPeriod = periodRecords[0].data.endPeriod;
            }
            let i = 0;
            for (const [k, v] of Object.entries(this.txHashes)) {
              let include = true;
              if (this.txs.period == "nodata") {
                if (v.timestamp != null) {
                  include = false;
                }
              } else {
                if (startPeriod != null && v.timestamp < startPeriod.unix()) {
                  include = false;
                }
                if (endPeriod != null && v.timestamp > endPeriod.unix()) {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  txHash: k,
                  timestamp: v.timestamp,
                  from: v.data.tx && v.data.tx.from || null,
                  to: v.data.tx && v.data.tx.to || null,
                });
              }
              i++;
            }
            return results;
          },
          filteredSortedTxs() {
            let results = this.filteredTxs;
            if (this.txs.sortOption == 'timeasc') {
              results.sort((a, b) => a.timestamp - b.timestamp);
            } else if (this.txs.sortOption == 'timedsc') {
              results.sort((a, b) => b.timestamp - a.timestamp);
            }
            return results;
          },
          pagedFilteredSortedTxs() {
            return this.filteredSortedTxs.slice((this.txs.currentPage - 1) * this.txs.pageSize, this.txs.currentPage * this.txs.pageSize);
          },
        },

        // --- METHODS ---
        methods: {
          async halt() {
            this.sync.halt = true;
            console.log("this.sync.halt: " + this.sync.halt);
          },
          formatTimestamp(ts) {
            if (ts != null) {
              return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
            }
            return null;
          },
          formatETH(e) {
            try {
              return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(9) : null;
            } catch (err) {
            }
            return e.toFixed(9);
          },
          ensOrAddress(address, length = 24) {
            if (this.ensMap) {
              if (address in this.ensMap) {
                return this.ensMap[address].substring(0, length);
              }
            }
            return address == null ? null : address.substring(0, length);
          },
          toggleTx(txHash) {
            if (!this.selectedTxs[txHash]) {
              Vue.set(this.selectedTxs, txHash, true);
            } else {
              Vue.delete(this.selectedTxs, txHash);
            }
          },
          toggleTxs(txItems) {
            let someFalse = false;
            let someTrue = false;
            for (const item of txItems) {
              if (this.selectedTxs[item.txHash]) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of txItems) {
              Vue.set(this.selectedTxs, item.txHash, !(someTrue && !someFalse));
            }
          },
          async processIt(action) {
            console.log("processIt: " + JSON.stringify(action));
            let connected = true;
            if (!window.ethereum) {
              connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                connected = false;
              }
            }
            if (!connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
              this.coinbase = await signer.getAddress();
              localStorage.coinbase = this.coinbase;
              const network = await provider.getNetwork();
              const block = await provider.getBlock("latest");
              const blockNumber = block.number;
              const timestamp = block.timestamp;
              const ENSOWNERBATCHSIZE = 100; // TODO 200; // 500 fails occassionally

              const db0 = new Dexie(this.db.name);
              db0.version(this.db.version).stores(this.db.schemaDefinition);

              if (action == "importHashes") {
                const importTxHashes = this.importTxHashes.hashes == null ? [] : this.importTxHashes.hashes.split(/[, \t\n]+/).filter(name => (name.length == 66 && name.substring(0, 2) == '0x'));
                console.log(JSON.stringify(importTxHashes, null, 2));
                let importOrder = 0;
                for (const txHash of importTxHashes) {
                  if (!(txHash in this.importTxHashes)) {
                    this.txHashes[txHash] = {
                      txHash,
                      timestamp: null,
                      // blockNumber: null,
                      // from: null,
                      data: {
                        tx: null,
                        txReceipt: null,
                        ethBalance: null,
                        ethBalancePreviousBlock: null,
                        imported: timestamp,
                        importOrder,
                      },
                    };
                    importOrder++;
                  }
                }
                await db0.cache.put({ objectName: 'txHashes', object: this.txHashes }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "retrieveData") {
                console.log("Retrieving data");
                const txHashesToProcess = [];
                for (const [txHash, txItem] of Object.entries(this.txHashes)) {
                  if (txItem.timestamp == null) {
                    txHashesToProcess.push(txHash);
                  }
                }
                this.sync.total = Object.keys(this.txHashes).length;
                this.sync.completed = this.sync.total - txHashesToProcess.length;
                this.sync.section = "Retrieve Data";
                let i = 0;
                for (const txHash of txHashesToProcess) {
                  const tx = await provider.getTransaction(txHash);
                  const txReceipt = await provider.getTransactionReceipt(txHash);
                  const block = await provider.getBlock(txReceipt.blockNumber);
                  const ethBalance = await provider.getBalance(tx.from, txReceipt.blockNumber);
                  const ethBalancePreviousBlock = await provider.getBalance(tx.from, txReceipt.blockNumber - 1);
                  this.txHashes[txHash].timestamp = block.timestamp;
                  this.txHashes[txHash].data.tx = {
                    hash: tx.hash,
                    type: tx.type,
                    blockHash: tx.blockHash,
                    blockNumber: tx.blockNumber,
                    transactionIndex: tx.transactionIndex,
                    from: tx.from,
                    gasPrice: tx.gasPrice,
                    gasLimit: tx.gasLimit,
                    to: tx.to,
                    value: tx.value,
                    nonce: tx.nonce,
                    data: tx.data,
                    r: tx.r,
                    s: tx.s,
                    v: tx.v,
                    chainId: tx.chainId,
                  };
                  this.txHashes[txHash].data.txReceipt = txReceipt;
                  this.txHashes[txHash].data.ethBalance = ethBalance;
                  this.txHashes[txHash].data.ethBalancePreviousBlock = ethBalancePreviousBlock;
                  // console.log(JSON.stringify(this.txHashes[txHash], null, 2));
                  this.sync.completed = parseInt(this.sync.completed) + 1;
                  i++;
                  if ((i % 10) == 9) {
                    await db0.cache.put({ objectName: 'txHashes', object: this.txHashes }).then (function() {
                    }).catch(function(error) {
                      console.log("error: " + error);
                    });
                  }
                  if (this.sync.halt) {
                    break;
                  }
                }
                await db0.cache.put({ objectName: 'txHashes', object: this.txHashes }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.sync.section = null;
              }

              const ensMap = {};
              ensMap[this.coinbase] = this.coinbase;
              for (const txItem of Object.values(this.txHashes)) {
                if (txItem.timestamp != null) {
                  const from = txItem.data.tx && txItem.data.tx.from || null;
                  if (from && !ensMap[from]) {
                    ensMap[from] = from;
                  }
                  const to = txItem.data.tx && txItem.data.tx.to || null;
                  if (to && !ensMap[to]) {
                    ensMap[to] = to;
                  }
                }
              }
              console.log("ensMap: " + JSON.stringify(ensMap, null, 2));
              this.sync.completed = 0;
              const addresses = Object.keys(ensMap);
              this.sync.total = addresses.length;
              this.sync.section = "ENS Names";
              for (let i = 0; i < addresses.length; i += ENSOWNERBATCHSIZE) {
                const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                console.log("batch: " + JSON.stringify(batch));
                const allnames = await ensReverseRecordsContract.getNames(batch);
                for (let j = 0; j < batch.length; j++) {
                  const address = batch[j];
                  const name = allnames[j];
                  ensMap[address] = name != null && name.length > 0 ? name : address;
                  // const normalized = normalize(address);
                }
                this.sync.completed = parseInt(this.sync.completed) + batch.length;
              }
              this.ensMap = ensMap;
              await db0.cache.put({ objectName: 'ensMap', object: ensMap }).then (function() {
              }).catch(function(error) {
                console.log("error: " + error);
              });

              db0.close();
              this.sync.section = null;
              this.sync.halt = false;
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          if ('coinbase' in localStorage) {
            this.coinbase = localStorage.coinbase;
          }
          (async() => {
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            const txHashes = await db0.cache.where("objectName").equals('txHashes').toArray();
            if (txHashes.length == 1) {
              this.txHashes = txHashes[0].object;
            }
            const ensMap = await db0.cache.where("objectName").equals('ensMap').toArray();
            if (ensMap.length == 1) {
              this.ensMap = ensMap[0].object;
            }
            db0.close();
          })();
        },
      })
    </script>
  </body>
</html>
