<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Txs</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Txs (c) Bok Consulting Pty Ltd 2022" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.6.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>
    <script src="txparser.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/ZombieBaby_001_gp2_3871_8601_10786.gif" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">Txs</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-avatar v-if="coinbase && coinbase != ensOrAddress(coinbase)" rounded variant="light" size="2.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensOrAddress(coinbase)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="primary" class="ml-1" @click="processIt('connect')" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? ensOrAddress(coinbase, 32) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Revoke permissions when not required, at this early stage.
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension, connect to the Ethereum mainnet and refresh this page. Then click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-card class="mx-1 mt-1 mb-1" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Addresses
            </template>
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.addressTable.searchAddresses" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'Filter by partial address, name'" placeholder="🔍 address"></b-form-input>
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.addressTable.addressTypeFilter" @change="settingsUpdated" :options="addressTypeFilters" v-b-popover.hover.top="'Filter by address types'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.addressTable.addressMineFilter" @change="settingsUpdated" :options="addressMineFilters" v-b-popover.hover.top="'Filter for my addresses, or not'"></b-form-select>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null" @click="processIt('computeAddresses')" variant="link" v-b-popover.hover.top="'Perform computations on addresses'"><b-icon-caret-right-square shift-v="+1" font-scale="0.9"></b-icon-caret-right-square></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-0">
                <b-button size="sm" :pressed.sync="settings.addAddresses" @click="settingsUpdated" variant="link" v-b-popover.hover.top="'Add addresses, tx hashes, Etherscan API key'"><span v-if="settings.addAddresses"><b-icon-plus-square-fill shift-v="+1" font-scale="1.0"></b-icon-plus-square-fill></span><span v-else><b-icon-plus-square shift-v="+1" font-scale="1.0"></b-icon-plus-square></span></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.editAddresses" @click="settingsUpdated" :variant="settings.editAddresses ? 'danger' : 'link'" v-b-popover.hover.top="settings.editAddresses ? 'End editing address attributes' : 'Edit address attributes'"><b-icon-pencil shift-v="+1" font-scale="1.0"></b-icon-pencil></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" @click="exportAddresses" variant="link">Export</b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.addressTable.sortOption" @change="settingsUpdated" :options="addressesSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <font size="-2" v-b-popover.hover.top="'# txs'">{{ filteredSortedAddresses.length }}</font>
              </div>
              <div class="mt-0 pr-1">
                <b-pagination size="sm" v-model="settings.addressTable.currentPage" @input="settingsUpdated" :total-rows="filteredSortedAddresses.length" :per-page="settings.addressTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.addressTable.pageSize" @change="settingsUpdated" :options="pageSizes" v-b-popover.hover.top="'Addresses page size'"></b-form-select>
              </div>
            </div>
            <b-card v-if="settings.addAddresses" no-body no-header bg-variant="light" class="m-1 p-1">
              <b-card-body class="m-1 p-1">
                <b-form-group label-cols-lg="2" label="Add Addresses" label-size="md" label-class="font-weight-bold pt-0" class="mb-0">
                  <b-form-group label="Addresses:" label-for="addaddresses-hashes" label-size="sm" label-cols-sm="2" label-align-sm="right" description="List of Ethereum addresses. These will be saved in your local browser storage and will be used in web3 and Etherscan API calls" class="mx-0 my-1 p-0">
                    <b-form-textarea size="sm" id="addaddresses-hashes" v-model.trim="addressesToAdd" rows="1" max-rows="5" class="w-75"  placeholder="0x1234... 0x2345..., 0xAbCd..."></b-form-textarea>
                  </b-form-group>
                  <b-form-group label="" label-for="addaddresses-submit" label-size="sm" label-cols-sm="2" label-cols-sm="2" label-align-sm="right" description="Valid addresses will be added below. Click the + to the right to show details and click Import" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="addaddresses-submit" :disabled="addressesToAdd == null || addressesToAdd.length == 0" @click="processIt('addAddresses')" variant="primary">Add</b-button>
                  </b-form-group>
                </b-form-group>

                <b-form-group label-cols-lg="2" label="Add Transaction Hashes" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                  <b-form-group label="Hashes:" label-for="importhashes-hashes" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Export from Etherscan.io and paste in the column of Ethereum tx hashes" class="mx-0 my-1 p-0">
                    <b-form-textarea size="sm" id="importhashes-hashes" v-model.trim="hashesToImport" rows="1" max-rows="5" class="w-75"></b-form-textarea>
                  </b-form-group>
                  <b-form-group label="" label-for="importhashes-submit" label-size="sm" label-cols-sm="2" label-align-sm="right" description="These will be saved into your local browser storage. The computation processes will retrieve further details via your web3 connection" class="mx-0 my-1 p-0">
                    <b-button size="sm" id="importhashes-submit" :disabled="hashesToImport == null || hashesToImport.length == 0" @click="processIt('importHashes')" variant="primary">Add</b-button>
                  </b-form-group>
                </b-form-group>

                <b-form-group label-cols-lg="2" label="Import Settings" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                  <b-form-group label="Etherscan API Key:" label-for="etherscan-apikey" label-size="sm" label-cols-sm="2" label-align-sm="right" description="This key is stored in your local browser storage and is sent with Etherscan API requests" class="mx-0 my-1 p-0">
                    <b-form-input type="text" size="sm" id="etherscan-apikey" v-model.trim="settings.etherscanAPIKey" @change="settingsUpdated" debounce="600" placeholder="See https://docs.etherscan.io/ to obtain an API key" class="w-75"></b-form-input>
                  </b-form-group>
                </b-form-group>

              </b-card-body>
            </b-card>
            <b-table small fixed striped selectable responsive hover :fields="addressesFields" :items="pagedFilteredSortedAddresses" show-empty empty-html="Click [+] above to add addresses and Ethereum transaction hashes, and set your Etherscan API key for imports. Click on your address on the top right to add it" head-variant="light" class="m-0 mt-1">
              <template #head(number)="data">
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSelectedAddresses(pagedFilteredSortedAddresses)">Toggle selection for all addresses on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSelectedAddresses(filteredSortedAddresses)">Toggle selection for all addresses on all pages</b-dropdown-item>
                  <b-dropdown-item href="#" @click="clearSelectedAddresses()">Clear selection</b-dropdown-item>
                </b-dropdown>
              </template>
              <template #cell(number)="data">
                <b-form-checkbox size="sm" :checked="selectedAddresses[data.item.address] ? 1 : 0" value="1" @change="toggleSelectedAddresses([data.item])">
                  {{ parseInt(data.index) + ((settings.addressTable.currentPage - 1) * settings.addressTable.pageSize) + 1 }}
                </b-form-checkbox>
              </template>
              <template #cell(type)="data">
                <b-button class="sm" :id="'popover-target-' + data.item.address" variant="link" class="m-0 p-0">
                  <b-icon-caret-right shift-v="+5" font-scale="0.8"></b-icon-caret-right>
                </b-button>
                <b-popover :target="'popover-target-' + data.item.address" placement="right" custom-class="popover-max-width">
                  <template #title>{{ ensOrAddress(data.item.address) }}</template>
                  <b-link @click="copyToClipboard(data.item.address);">Copy address to clipboard</b-link>
                  <span v-if="ensOrAddress(data.item.address) != data.item.address">
                    <br />
                    <b-link @click="copyToClipboard(ensOrAddress(data.item.address));">Copy ENS name to clipboard</b-link>
                    <br />
                    <b-link :href="'https://app.ens.domains/name/' + ensOrAddress(data.item.address)" target="_blank">View ENS name in app.ens.domains</b-link>
                  </span>
                  <br />
                  <b-link :href="'https://etherscan.io/address/' + data.item.address" target="_blank">View account in etherscan.io</b-link>
                  <br />
                  <b-link :href="'https://opensea.io/' + data.item.address" target="_blank">View account in opensea.io</b-link>
                  <br />
                  <b-link :href="'https://opensea.io/' + data.item.address + '?tab=bids'" target="_blank">View offers received in opensea.io</b-link>
                  <br />
                  <b-link :href="'https://looksrare.org/accounts/' + data.item.address + '#owned'" target="_blank">View account in looksrare.org</b-link>
                  <br />
                  <b-link :href="'https://x2y2.io/user/' + data.item.address + '/items'" target="_blank">View account in x2y2.io</b-link>
                  <br />
                  <b-link :href="'https://www.gem.xyz/profile/' + data.item.address" target="_blank">View account in gem.xyz</b-link>
                </b-popover>
                <!-- <div v-if="settings.editAddresses">
                  <b-form-select size="sm" :disabled="!settings.editAddresses" v-model="data.item.type" @change="addressesUpdated" :options="addressTypes" v-b-popover.hover.top="'Address type'"></b-form-select>
                </div>
                <div v-else>
                  {{ addressTypes.find(e => e.value == data.item.type).text }}
                </div> -->
              </template>
              <template #cell(mine)="data">
                <div v-if="settings.editAddresses">
                  <b-form-checkbox size="sm" :checked="data.item.mine ? 1 : 0" value="1" @change="toggleAddressMine(data.item.address)">
                  </b-form-checkbox>
                </div>
                <div v-else>
                  <b-form-checkbox size="sm" disabled :checked="data.item.mine ? 1 : 0" value="1">
                  </b-form-checkbox>
                </div>
              </template>
              <template #cell(address)="data">
                <div class="d-flex flex-row">
                  <div style="min-width: 3.0rem;">
                    <b-avatar v-if="ensOrAddress(data.item.address) != data.item.address" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensOrAddress(data.item.address)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
                  </div>
                  <div>
                    <b-badge variant="default">{{ data.item.address }}</b-badge>
                    <br />
                    <b-badge v-if="ensOrAddress(data.item.address) != data.item.address" variant="default">{{ ensOrAddress(data.item.address) }}</b-badge>
                  </div>
                </div>
              </template>
              <!-- <template #cell(ens)="data">
                <b-link v-if="ensOrAddress(data.item.address) != data.item.address" :href="'https://etherscan.io/address/' + data.item.address" v-b-popover.hover.bottom="'View in Etherscan.io'" target="_blank">
                  {{ ensOrAddress(data.item.address) }}
                </b-link>
              </template> -->
              <template #cell(group)="data">
                <div v-if="settings.editAddresses">
                  <b-form-input type="text" size="sm" v-model.trim="addresses[data.item.address].group" @change="addressesUpdated" debounce="600"></b-form-input>
                </div>
                <div v-else>
                  {{ data.item.group }}
                </div>
              </template>
              <template #cell(name)="data">
                <div v-if="settings.editAddresses">
                  <b-form-input type="text" size="sm" v-model.trim="addresses[data.item.address].name" @change="addressesUpdated" debounce="600"></b-form-input>
                </div>
                <div v-else>
                  {{ data.item.name }}
                </div>
              </template>
              <template #cell(notes)="data">
                <div v-if="settings.editAddresses">
                  <b-form-input type="text" size="sm" v-model.trim="addresses[data.item.address].notes" @change="addressesUpdated" debounce="600"></b-form-input>
                </div>
                <div v-else>
                  {{ data.item.notes }}
                </div>
              </template>
              <template #cell(end)="data">
                <b-button size="sm" @click="toggleAddressDetails(data)" variant="link" class="m-0 p-0" v-b-popover.hover="data.item._showDetails ? 'Hide details' : 'Show details'"><span v-if="data.item._showDetails"><b-icon-arrows-angle-contract shift-v="+1" font-scale="0.9"></b-icon-arrows-angle-contract></span><span v-else><b-icon-arrows-angle-expand shift-v="+1" font-scale="0.9"></b-icon-arrows-angle-expand></span></b-button>
              </template>
              <template #row-details="data">
                <b-card>
                  <b-row class="mb-2">
                    <b-col sm="3" class="text-sm-right"><b>Address:</b></b-col>
                    <b-col>{{ data.item.address }}</b-col>
                  </b-row>
                  <b-row class="mb-2">
                    <b-col sm="3" class="text-sm-right"><b>ENS:</b></b-col>
                    <b-col>{{ ensOrAddress(data.item.address) }}</b-col>
                  </b-row>
                  <b-row class="mb-2">
                    <b-col sm="3" class="text-sm-right"><b>Import transactions:</b></b-col>
                    <b-col><b-button size="sm" @click="processIt('importFromEtherscan', data.item.address)" variant="primary" v-b-popover.hover.top="'Import from Etherscan, rate limited to 1 request every 5 seconds'">Import</b-button></b-col>
                  </b-row>
                  <!-- <b-button size="sm" @click="toggleAddressDetails(data)" variant="link" v-b-popover.hover.top="data.item._showDetails ? 'Hide details' : 'Show details'"><span v-if="data.item._showDetails"><b-icon-dash shift-v="+1" font-scale="1.0"></b-icon-dash></span><span v-else><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></span></b-button> -->
                </b-card>
              </template>
            </b-table>
          </b-card>

          <!-- <b-card v-if="settings.showImport" no-body no-header bg-variant="light" class="m-1 p-1 w-75">
            <b-card-body class="m-1 p-1">
              <b-form-group label-cols-lg="2" label="Import Hashes" label-size="md" label-class="font-weight-bold pt-0" class="mb-0">
                <b-form-group label="Hashes:" label-for="importhashes-hashes" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Export from Etherscan.io and paste in the column of Ethereum tx hashes" class="mx-0 my-1 p-0">
                  <b-form-textarea size="sm" id="importhashes-hashes" v-model.trim="hashesToImport" rows="1" max-rows="5" class="w-100"></b-form-textarea>
                </b-form-group>
                <b-form-group label="" label-for="importhashes-submit" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Tx hashes will be saved into your local browser storage" class="mx-0 my-1 p-0">
                  <b-button size="sm" id="importhashes-submit" :disabled="hashesToImport == null || hashesToImport.length == 0" @click="processIt('importHashes')" variant="warning">Import</b-button>
                </b-form-group>
              </b-form-group>
            </b-card-body>
          </b-card> -->

          <b-card-body class="m-0 px-1 py-0 pt-1">
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.txs.searchTxs" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'Filter by partial tx hash, address, name'" placeholder="🔍 {txHash|addr|name} "></b-form-input>
              </div>
              <!-- <div class="mt-0 pr-0">
                <b-button size="sm" :pressed.sync="settings.showImport" @change="settingsUpdated" variant="link" v-b-popover.hover.top="'Show import dialog to import hashes'"><span v-if="settings.showImport"><b-icon-plus-square-fill shift-v="+1" font-scale="1.0"></b-icon-plus-square-fill></span><span v-else><b-icon-plus-square shift-v="+1" font-scale="1.0"></b-icon-plus-square></span></b-button>
              </div> -->
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null" @click="processIt('retrieveData')" variant="primary" style="min-width: 40px;" v-b-popover.hover.top="'Retrieve tx data via web3 for your imported tx hashes'"><b-icon-cloud-download shift-v="+1" font-scale="0.9"></b-icon-cloud-download></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.txs.period" :options="txsPeriodOptions" @change="settingsUpdated" v-b-popover.hover.top="'Period'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null" @click="processIt('compute')" variant="link" v-b-popover.hover.top="'Perform computations on selected items'"><b-icon-caret-right-square shift-v="+1" font-scale="0.9"></b-icon-caret-right-square></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-1" style="width: 200px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" @click="exportTxHashes" variant="link">Export</b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <!-- <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.showAddresses" @click="settingsUpdated" variant="link" v-b-popover.hover.top="'Show addresses'"><span v-if="settings.showAddresses"><b-icon-people-fill shift-v="+1" font-scale="1.0"></b-icon-people-fill></span><span v-else><b-icon-people shift-v="+1" font-scale="1.0"></b-icon-people></span></b-button>
              </div> -->
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.txs.sortOption" @change="settingsUpdated" :options="txsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <font size="-2" v-b-popover.hover.top="'# txs'">{{ filteredSortedTxs.length }}</font>
              </div>
              <div class="mt-0 pr-1">
                <b-pagination size="sm" v-model="settings.txs.currentPage" @input="settingsUpdated" :total-rows="filteredSortedTxs.length" :per-page="settings.txs.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.txs.pageSize" @change="settingsUpdated" :options="pageSizes" v-b-popover.hover.top="'Transactions page size'"></b-form-select>
              </div>
            </div>

            <b-table small fixed striped selectable responsive hover :fields="txsFields" :items="pagedFilteredSortedTxs" show-empty head-variant="light" class="m-0 mt-1">
              <template #head(number)="data">
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSelectedTxs(pagedFilteredSortedTxs)">Toggle selection for all transactions on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSelectedTxs(filteredSortedTxs)">Toggle selection for all transactions on all pages</b-dropdown-item>
                  <b-dropdown-item href="#" @click="clearSelectedTxs()">Clear selection</b-dropdown-item>
                </b-dropdown>
              </template>
              <template #cell(number)="data">
                <b-form-checkbox size="sm" :checked="selectedTxs[data.item.txHash] ? 1 : 0" value="1" @change="toggleSelectedTxs([data.item])">
                  {{ parseInt(data.index) + ((settings.txs.currentPage - 1) * settings.txs.pageSize) + 1 }}
                </b-form-checkbox>
              </template>
              <template #cell(timestamp)="data">
                <b-link :href="'https://etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'View in Etherscan.io'" target="_blank">{{ formatTimestamp(data.item.timestamp) }}</b-link>
              </template>
              <template #cell(from)="data">
                <div v-if="addressName(data.item.from).type == 'name'">
                  <b-badge variant="default" v-b-popover.hover.bottom="'From address'">{{ addressName(data.item.from).name }}</b-badge>
                </div>
                <div v-else>
                  <b-link :href="'https://etherscan.io/address/' + data.item.from" v-b-popover.hover.bottom="'View address in Etherscan.io'" target="_blank">
                    <b-badge variant="default">{{ addressName(data.item.from).name }}</b-badge>
                  </b-link>
                </div>
              </template>
              <template #cell(to)="data">
                <div v-if="addressName(data.item.to).type == 'name'">
                  <b-badge variant="default" v-b-popover.hover.bottom="'To address'">{{ addressName(data.item.to).name }}</b-badge>
                </div>
                <div v-else>
                  <b-link :href="'https://etherscan.io/address/' + data.item.to" v-b-popover.hover.bottom="'View address in Etherscan.io'" target="_blank">
                    <b-badge variant="default">{{ addressName(data.item.to).name }}</b-badge>
                  </b-link>
                </div>
              </template>
              <template #cell(blah)="data">
                <!-- Blah -->
              </template>
              <template #cell(txHash)="data">
                <!-- <b-link :href="'https://etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'View tx in Etherscan.io'" target="_blank">
                  {{ data.item.txHash.substring(0, 16) }}
                </b-link> -->
                <!-- <b-button size="sm" @click="toggleTxsDetails(data)" variant="link" v-b-popover.hover.top="data.item._showDetails ? 'Hide details' : 'Show details'"><span v-if="data.item._showDetails"><b-icon-dash shift-v="+1" font-scale="1.0"></b-icon-dash></span><span v-else><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></span></b-button> -->
              </template>
              <template #cell(balance)="data">
                <font size="-2">
                  <b-badge variant="default" v-b-popover.hover.bottom="'From account balance, previous block'">{{ formatETH(data.item.ethBalancePreviousBlock) }}</b-badge>
                </font>
                <b-badge variant="default" v-b-popover.hover.bottom="'From account balance'">{{ formatETH(data.item.ethBalance) }}</b-badge>
              </template>
              <template #cell(end)="data">
                <b-button size="sm" @click="toggleTxsDetails(data)" variant="link" v-b-popover.hover.top="data.item._showDetails ? 'Hide details' : 'Show details'"><span v-if="data.item._showDetails"><b-icon-dash shift-v="+1" font-scale="1.0"></b-icon-dash></span><span v-else><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></span></b-button>
              </template>
              <template #row-details="data">
                <b-card>
                  <b-row class="mb-2">
                    <b-col sm="3" class="text-sm-right"><b>Tx Hash:</b></b-col>
                    <b-col>{{ data.item.txHash }}</b-col>
                  </b-row>
                  <b-row class="mb-2">
                    <b-col sm="3" class="text-sm-right"><b>From:</b></b-col>
                    <b-col>{{ ensOrAddress(data.item.from) }}</b-col>
                  </b-row>
                  <!-- <b-button size="sm" @click="toggleTxsDetails(data)" variant="link" v-b-popover.hover.top="data.item._showDetails ? 'Hide details' : 'Show details'"><span v-if="data.item._showDetails"><b-icon-dash shift-v="+1" font-scale="1.0"></b-icon-dash></span><span v-else><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></span></b-button> -->
                </b-card>
              </template>
            </b-table>
          </b-card-body>
        </b-card>
        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <b-card-text class="text-right">
            gm, and enjoy! <i>Txs</i> &copy; Bok Consulting Pty Ltd 2022.
          </b-card-text>
        </b-card no-header>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          coinbase: null,
          settings: {
            showImport: false, // TODO: Delete
            addAddresses: false,
            editAddresses: false,
            etherscanAPIKey: null,
            addressTable: {
              searchAddresses: null,
              addressTypeFilter: null,
              addressMineFilter: null,
              showDetails: {},
              currentPage: 1,
              pageSize: 10,
              sortOption: 'addressasc',
            },
            txs: {
              searchTxs: null,
              period: null,
              showDetails: {},
              currentPage: 1,
              pageSize: 100,
              sortOption: 'timeasc',
            },
          },
          addressesToAdd: null,
          hashesToImport: null,
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },
          addresses: {},
          txHashes: {},
          importData: {},
          ensMap: {},
          selectedAddresses: {},
          selectedTxs: {},

          addressesSortOptions: [
            { value: 'addressasc', text: '▲ Address' },
            { value: 'addressdsc', text: '▼ Address' },
            { value: 'groupasc', text: '▲ Group, ▲ Name' },
            { value: 'groupdsc', text: '▼ Group, ▲ Name' },
            { value: 'nameasc', text: '▲ Name, ▲ Group' },
            { value: 'namedsc', text: '▼ Name, ▲ Group' },
          ],
          txsSortOptions: [
            { value: 'timeasc', text: '▲ Time' },
            { value: 'timedsc', text: '▼ Time' },
            { value: 'fromasc', text: '▲ From' },
            { value: 'fromdsc', text: '▼ From' },
            { value: 'toasc', text: '▲ To' },
            { value: 'todsc', text: '▼ To' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          addressTypes: [
            { value: null, text: '(unknown)' },
            { value: 'eoa', text: 'EOA' },
            { value: 'contract', text: 'Contract' },
            { value: 'erc721', text: 'ERC-721' },
            { value: 'erc1155', text: 'ERC-1155' },
            { value: 'erc20', text: 'ERC-20' },
          ],
          addressTypeFilters: [
            { value: null, text: '(all)' },
            { value: 'eoa', text: 'EOA' },
            { value: 'contract', text: 'Contract' },
            { value: 'erc721', text: 'ERC-721' },
            { value: 'erc1155', text: 'ERC-1155' },
            { value: 'erc20', text: 'ERC-20' },
            { value: 'unknown', text: '(unknown)' },
          ],
          addressMineFilters: [
            { value: null, text: '(any)' },
            { value: 'mine', text: 'Mine' },
            { value: 'notmine', text: 'Not Mine' },
          ],
          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'address', label: 'Address / ENS Name', sortable: false, thStyle: 'width: 30%;', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'mine', label: 'Mine', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            // { key: 'ens', label: 'ENS', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'group', label: 'Group', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'notes', label: 'Notes', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'end', label: '', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          txsFields: [
            { key: 'number', label: '#', thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'Timestamp', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'from', label: 'From', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'to', label: 'To', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'blah', label: 'Blah', thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'txHash', label: 'Transactions', thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'balance', label: 'Balance', /*sortable: true,*/ thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'end', label: '', sortable: false, thStyle: 'width: 5%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          db: {
            name: "txs089",
            version: 1,
            schemaDefinition: {
              cache: '&objectName',
              // collection: '&address',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          txsPeriodOptions() {
            const results = [];
            results.push({ value: null, text: "(select period)", data: null });
            const startMonth = "Jul";
            const now = moment();
            let currentStartPeriod = moment(now).month(startMonth).startOf('month');
            if (currentStartPeriod > now) {
              currentStartPeriod = currentStartPeriod.subtract(1, 'year');
            }
            for (let year = 0; year < 7; year++) {
              const startPeriod = moment(currentStartPeriod).subtract(year, 'year');
              const endPeriod = moment(startPeriod).add(1, 'year').subtract(1, 'second');
              results.push({ value: "fym" + year, text: startPeriod.format('MMM DD YYYY') + " to " + endPeriod.format('MMM DD YYYY'), data: { startPeriod, endPeriod } });
            }
            results.push({ value: "nodata", text: "(tx hashes with no data)", data: null });
            return results;
          },
          filteredAddresses() {
            const results = [];
            const searchAddressesLower = this.settings.addressTable.searchAddresses && this.settings.addressTable.searchAddresses.toLowerCase() || null;
            for (const [address, item] of Object.entries(this.addresses)) {
              const ensName = this.ensMap[address] || null;
              let include = searchAddressesLower == null ||
                (item.name && item.name.toLowerCase().includes(searchAddressesLower)) ||
                (item.group && item.group.toLowerCase().includes(searchAddressesLower)) ||
                (item.address && item.address.toLowerCase().includes(searchAddressesLower)) ||
                (item.notes && item.notes.toLowerCase().includes(searchAddressesLower) ||
                (ensName != null && ensName.toLowerCase().includes(searchAddressesLower)));
              if (include && this.settings.addressTable.addressMineFilter != null) {
                if (this.settings.addressTable.addressMineFilter == 'mine' && item.mine) {
                } else if (this.settings.addressTable.addressMineFilter == 'notmine' && !item.mine) {
                } else {
                  include = false;
                }
              }
              if (include && this.settings.addressTable.addressTypeFilter != null) {
                if (this.settings.addressTable.addressTypeFilter == 'unknown' && item.type == null) {
                } else if (this.settings.addressTable.addressTypeFilter == item.type) {
                } else {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  address,
                  type: item.type,
                  mine: item.mine,
                  ensName: item.ensName,
                  group: item.group,
                  name: item.name,
                  tags: item.tags,
                  notes: item.notes,
                  _showDetails: this.settings.addressTable.showDetails[address] || false,
                });
              }
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
            if (this.settings.addressTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.address).localeCompare(b.address);
              });
            } else if (this.settings.addressTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.address).localeCompare(a.address);
              });
            } else if (this.settings.addressTable.sortOption == 'groupasc') {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.group).localeCompare(b.group);
                }
              });
            } else if (this.settings.addressTable.sortOption == 'groupdsc') {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + b.group).localeCompare(a.group);
                }
              });
            } else if (this.settings.addressTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  if (('' + a.group).localeCompare(b.group) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + a.group).localeCompare(b.group);
                  }
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.addressTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  if (('' + a.group).localeCompare(b.group) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + a.group).localeCompare(b.group);
                  }
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            }
            return results;
          },
          pagedFilteredSortedAddresses() {
            return this.filteredSortedAddresses.slice((this.settings.addressTable.currentPage - 1) * this.settings.addressTable.pageSize, this.settings.addressTable.currentPage * this.settings.addressTable.pageSize);
          },
          filteredTxs() {
            const results = [];
            let startPeriod = null;
            let endPeriod = null;
            const searchTxsLower = this.settings.txs.searchTxs && this.settings.txs.searchTxs.toLowerCase() || null;
            if (this.settings.txs.period != null && this.settings.txs.period != "nodata") {
              const periodRecords = this.txsPeriodOptions.filter(e => e.value == this.settings.txs.period);
              startPeriod = periodRecords[0].data.startPeriod;
              endPeriod = periodRecords[0].data.endPeriod;
            }
            let i = 0;
            const hasAddressesFilter = Object.keys(this.selectedAddresses).length > 0;
            for (const [k, v] of Object.entries(this.txHashes)) {
              let include = true;
              if (this.settings.txs.period == "nodata") {
                if (v.timestamp != null) {
                  include = false;
                }
              } else {
                if (startPeriod != null && v.timestamp < startPeriod.unix()) {
                  include = false;
                }
                if (include && endPeriod != null && v.timestamp > endPeriod.unix()) {
                  include = false;
                }
                if (include && hasAddressesFilter) {
                  if (!this.selectedAddresses[v.data.tx.from] && !(v.data.tx.to && this.selectedAddresses[v.data.tx.to])) {
                    include = false;
                  }
                }
                if (include && searchTxsLower != null) {
                  // console.log("searchTxsLower: " + searchTxsLower + " vs " + v.data.tx.from + " check " + v.data.tx.from.toLowerCase().includes(searchTxsLower));
                  if (
                    !(v.txHash.includes(searchTxsLower)) &&
                    !(v.data.tx.from.toLowerCase().includes(searchTxsLower)) &&
                    !(v.data.tx.to && v.data.tx.to.toLowerCase().includes(searchTxsLower))
                  ) {
                    include = false;
                  }
                }
              }
              if (include) {
                results.push({
                  txHash: k,
                  timestamp: v.timestamp,
                  from: v.data.tx && v.data.tx.from || null,
                  to: v.data.tx && v.data.tx.to || null,
                  ethBalance: v.data.ethBalance || null,
                  ethBalancePreviousBlock: v.data.ethBalancePreviousBlock || null,
                  _showDetails: this.settings.txs.showDetails[k] || false,
                });
              }
              i++;
            }
            return results;
          },
          filteredSortedTxs() {
            let results = this.filteredTxs;
            if (this.settings.txs.sortOption == 'timeasc') {
              results.sort((a, b) => a.timestamp - b.timestamp);
            } else if (this.settings.txs.sortOption == 'timedsc') {
              results.sort((a, b) => b.timestamp - a.timestamp);
            } else if (this.settings.txs.sortOption == 'fromasc') {
              results.sort((a, b) => ('' + a.from.toString()).localeCompare(b.from.toString()))
            } else if (this.settings.txs.sortOption == 'fromdsc') {
              results.sort((a, b) => ('' + b.from.toString()).localeCompare(a.from.toString()))
            } else if (this.settings.txs.sortOption == 'toasc') {
              results.sort((a, b) => ('' + (a.to && a.to.toString() || '')).localeCompare((b.to && b.to.toString() || '')))
            } else if (this.settings.txs.sortOption == 'todsc') {
              results.sort((a, b) => ('' + (b.to && b.to.toString() || '')).localeCompare((a.to && a.to.toString() || '')))
            }
            return results;
          },
          pagedFilteredSortedTxs() {
            return this.filteredSortedTxs.slice((this.settings.txs.currentPage - 1) * this.settings.txs.pageSize, this.settings.txs.currentPage * this.settings.txs.pageSize);
          },
        },

        // --- METHODS ---
        methods: {
          async halt() {
            this.sync.halt = true;
            console.log("this.sync.halt: " + this.sync.halt);
          },
          formatTimestamp(ts) {
            if (ts != null) {
              return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
            }
            return null;
          },
          formatETH(e) {
            try {
              return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(9) : null;
            } catch (err) {
            }
            return e.toFixed(9);
          },
          addressName(address, length = 24) {
            if (address in this.addresses) {
              // console.log(JSON.stringify(this.addresses[address]));
              const item = this.addresses[address];
              if (item.name != null) {
                if (item.group != null) {
                  return { name: item.group + ':' + item.name, type: 'name' };
                } else {
                  return { name: item.name, type: 'name' };
                }
              } else if (item.ensName != null) {
                return { name: item.ensName, type: 'ens' };
              }
            }
            return address == null ? { name: null, type: 'null' } : { name: address.substring(0, length), type: 'address' };
          },
          ensOrAddress(address, length = 0) {
            if (this.ensMap) {
              if (address in this.ensMap) {
                return length == 0 ? this.ensMap[address] : this.ensMap[address].substring(0, length);
              }
            }
            return address == null ? null : (length == 0 ? address : address.substring(0, length));
          },
          toggleSelectedAddresses(items) {
            let someFalse = false;
            let someTrue = false;
            for (const item of items) {
              if (this.selectedAddresses[item.address]) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of items) {
              if (!(someTrue && !someFalse)) {
                Vue.set(this.selectedAddresses, item.address, true);
              } else {
                Vue.delete(this.selectedAddresses, item.address);
              }
            }
            localStorage.selectedAddresses = JSON.stringify(this.selectedAddresses);
          },
          clearSelectedAddresses() {
            this.selectedAddresses = {};
            localStorage.selectedAddresses = JSON.stringify(this.selectedAddresses);
          },
          async toggleAddressMine(address) {
            if (!this.addresses[address].mine) {
              Vue.set(this.addresses[address], 'mine', true);
            } else {
              Vue.set(this.addresses[address], 'mine', false);
            }
            // console.log("toggleAddressMine: " + JSON.stringify(this.addresses, null, 2));
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            await db0.cache.put({ objectName: 'addresses', object: this.addresses }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            db0.close();
          },
          toggleAddressDetails(data) {
            // console.log("toggleAddressDetails: " + JSON.stringify(data, null, 2));
            const currentState = this.settings.addressTable.showDetails[data.item.address] || false;
            if (!currentState) {
              Vue.set(this.settings.addressTable.showDetails, data.item.address, !currentState);
            } else {
              Vue.delete(this.settings.addressTable.showDetails, data.item.address);
            }
            this.settingsUpdated();
          },
          toggleSelectedTxs(txItems) {
            let someFalse = false;
            let someTrue = false;
            for (const item of txItems) {
              if (this.selectedTxs[item.txHash]) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of txItems) {
              if (!(someTrue && !someFalse)) {
                Vue.set(this.selectedTxs, item.txHash, true);
              } else {
                Vue.delete(this.selectedTxs, item.txHash);
              }
            }
            localStorage.selectedTxs = JSON.stringify(this.selectedTxs);
          },
          clearSelectedTxs() {
            this.selectedTxs = {};
            localStorage.selectedTxs = JSON.stringify(this.selectedTxs);
          },
          toggleTxsDetails(data) {
            console.log("toggleTxsDetails: " + JSON.stringify(data, null, 2));
            const currentState = this.settings.txs.showDetails[data.item.txHash] || false;
            if (!currentState) {
              Vue.set(this.settings.txs.showDetails, data.item.txHash, !currentState);
            } else {
              Vue.delete(this.settings.txs.showDetails, data.item.txHash);
            }
            this.settingsUpdated();
          },
          settingsUpdated() {
            console.log("settingsUpdated: " + JSON.stringify(this.settings, null, 2));
            localStorage.settings = JSON.stringify(this.settings);
          },
          async addressesUpdated() {
            // console.log("addressesUpdated");
            // localStorage.txsPeriod = this.settings.txs.period;
            // console.log("addressesUpdated: " + JSON.stringify(this.addresses, null, 2));
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            await db0.cache.put({ objectName: 'addresses', object: this.addresses }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            db0.close();
          },
          exportTxHashes() {
            console.log("exportTxHashes");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.txHashes));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "txhashes.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          exportAddresses() {
            console.log("exportAddresses");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.addresses));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "addresses.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          copyToClipboard(str) {
            // https://github.com/30-seconds/30-seconds-of-code/blob/master/snippets/copyToClipboard.md
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            const selected =
              document.getSelection().rangeCount > 0
                ? document.getSelection().getRangeAt(0)
                : false;
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            if (selected) {
              document.getSelection().removeAllRanges();
              document.getSelection().addRange(selected);
            }
          },
          async processIt(action, parameters = null) {
            console.log("processIt - action: " + action + ", parameters: " + parameters);
            let connected = true;
            if (!window.ethereum) {
              connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                connected = false;
              }
            }
            if (!connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
              const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS, ERC721HELPERABI, provider);
              this.coinbase = await signer.getAddress();
              localStorage.coinbase = this.coinbase;
              const network = await provider.getNetwork();
              const block = await provider.getBlock("latest");
              const blockNumber = block.number;
              const timestamp = block.timestamp;
              const ENSOWNERBATCHSIZE = 100; // 500 fails occassionally

              const db0 = new Dexie(this.db.name);
              db0.version(this.db.version).stores(this.db.schemaDefinition);

              // TODO
              if (action == "importFromEtherscan") {
                const address = parameters;
                const apikey = this.settings.etherscanAPIKey || "YourApiKeyToken";
                let importUrl = "https://api.etherscan.io/api?module=account&action=txlist&address=" + address + "&startblock=0&endblock=" + blockNumber + "&page=1&offset=10000&sort=asc&apikey=" + apikey;
                // console.log("importUrl: " + importUrl);
                const importData = await fetch(importUrl)
                  .then(handleErrors)
                  .then(response => response.json())
                  .catch(function(error) {
                     console.log("ERROR - processIt: " + error);
                     // Want to work around API data unavailablity - state.sync.error = true;
                     return [];
                  });
                console.log("importData: " + JSON.stringify(importData, null, 2));
                if (importData.status == 1) {
                  Vue.set(this.importData, address, {
                    address,
                    timestamp,
                    result: importData.result,
                  })
                  await db0.cache.put({ objectName: 'importData', object: this.importData }).then (function() {
                  }).catch(function(error) {
                    console.log("error: " + error);
                  });
                }
              }

              if (action == "importHashes") {
                const hashesToImport = this.hashesToImport == null ? [] : this.hashesToImport.split(/[, \t\n]+/).filter(name => (name.length == 66 && name.substring(0, 2) == '0x'));
                console.log(JSON.stringify(hashesToImport, null, 2));
                let importOrder = 0;
                for (const txHash of hashesToImport) {
                  if (!(txHash in this.txHashes)) {
                    this.txHashes[txHash] = {
                      txHash,
                      timestamp: null,
                      // blockNumber: null,
                      // from: null,
                      data: {
                        tx: null,
                        txReceipt: null,
                        ethBalance: null,
                        ethBalancePreviousBlock: null,
                        imported: timestamp,
                        importOrder,
                      },
                    };
                    importOrder++;
                  }
                }
                await db0.cache.put({ objectName: 'txHashes', object: this.txHashes }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "connect" || action == "addAddresses") {
                const addAddresses = (action == "connect") ? [this.coinbase] : (this.addressesToAdd == null ? [] : this.addressesToAdd.split(/[, \t\n]+/).filter(name => (name.length == 42 && name.substring(0, 2) == '0x')));
                for (let address of addAddresses) {
                  try {
                    console.log("Processing address: " + address);
                    const checksummedAddress = ethers.utils.getAddress(address);
                    if (checksummedAddress && !(checksummedAddress in this.addresses)) {
                      const info = await getAddressInfo(checksummedAddress, erc721Helper, provider);
                      console.log("info: " + JSON.stringify(info, null, 2));
                      Vue.set(this.addresses, checksummedAddress, {
                        address: checksummedAddress,
                        type: info && info.type || null,
                        mine: address == this.coinbase,
                        ensName: null,
                        group: null,
                        name: info && info.symbol && info.name && (info.symbol + ': ' + info.name) || null,
                        tags: [],
                        notes: null,
                        contract: {
                          name: info && info.name || null,
                          symbol: info && info.symbol || null,
                          decimals: info && info.decimals || null,
                        }
                      });
                    }
                  } catch (e) {
                    console.log(e.toString());
                  }
                }
                await db0.cache.put({ objectName: 'addresses', object: this.addresses }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "retrieveData") {
                console.log("Retrieving data");
                const txHashesToProcess = [];
                for (const [txHash, txItem] of Object.entries(this.txHashes)) {
                  if (txItem.timestamp == null) {
                    txHashesToProcess.push(txHash);
                  }
                }
                this.sync.total = Object.keys(this.txHashes).length;
                this.sync.completed = this.sync.total - txHashesToProcess.length;
                this.sync.section = "Retrieve Data";
                let i = 0;
                for (const txHash of txHashesToProcess) {
                  const tx = await provider.getTransaction(txHash);
                  const txReceipt = await provider.getTransactionReceipt(txHash);
                  const block = await provider.getBlock(txReceipt.blockNumber);
                  const ethBalance = await provider.getBalance(tx.from, txReceipt.blockNumber);
                  const ethBalancePreviousBlock = await provider.getBalance(tx.from, txReceipt.blockNumber - 1);
                  this.txHashes[txHash].timestamp = block.timestamp;
                  this.txHashes[txHash].data.tx = {
                    hash: tx.hash,
                    type: tx.type,
                    blockHash: tx.blockHash,
                    blockNumber: tx.blockNumber,
                    transactionIndex: tx.transactionIndex,
                    from: tx.from,
                    gasPrice: tx.gasPrice,
                    gasLimit: tx.gasLimit,
                    to: tx.to,
                    value: tx.value,
                    nonce: tx.nonce,
                    data: tx.data,
                    r: tx.r,
                    s: tx.s,
                    v: tx.v,
                    chainId: tx.chainId,
                  };
                  this.txHashes[txHash].data.txReceipt = txReceipt;
                  this.txHashes[txHash].data.ethBalance = ethBalance;
                  this.txHashes[txHash].data.ethBalancePreviousBlock = ethBalancePreviousBlock;
                  // console.log(JSON.stringify(this.txHashes[txHash], null, 2));
                  this.sync.completed = parseInt(this.sync.completed) + 1;
                  i++;
                  if ((i % 10) == 9) {
                    await db0.cache.put({ objectName: 'txHashes', object: this.txHashes }).then (function() {
                    }).catch(function(error) {
                      console.log("error: " + error);
                    });
                  }
                  if (this.sync.halt) {
                    break;
                  }
                }
                await db0.cache.put({ objectName: 'txHashes', object: this.txHashes }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.sync.section = null;
              }

              if (action == "addAddresses" || action == "retrieveData" || action == "connect") {
                const ensMap = {};
                // TODO
                // ensMap[this.coinbase] = this.coinbase;
                // for (const txItem of Object.values(this.txHashes)) {
                //   if (txItem.timestamp != null) {
                //     const from = txItem.data.tx && txItem.data.tx.from || null;
                //     if (from && !ensMap[from]) {
                //       ensMap[from] = from;
                //     }
                //     const to = txItem.data.tx && txItem.data.tx.to || null;
                //     if (to && !ensMap[to]) {
                //       ensMap[to] = to;
                //     }
                //   }
                // }
                // console.log("ensMap: " + JSON.stringify(ensMap, null, 2));

                for (const addressItem of Object.values(this.addresses)) {
                  if (addressItem.address && !ensMap[addressItem.address]) {
                    ensMap[addressItem.address] = addressItem.address;
                  }
                }

                this.sync.completed = 0;
                const addresses = Object.keys(ensMap);
                this.sync.total = addresses.length;
                this.sync.section = "ENS Names";
                for (let i = 0; i < addresses.length & !this.sync.halt; i += ENSOWNERBATCHSIZE) {
                  const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                  // console.log("batch: " + JSON.stringify(batch));
                  const allnames = await ensReverseRecordsContract.getNames(batch);
                  for (let j = 0; j < batch.length; j++) {
                    const address = batch[j];
                    const name = allnames[j];
                    ensMap[address] = name != null && name.length > 0 ? name : address;
                    // const normalized = normalize(address);
                  }
                  this.sync.completed = parseInt(this.sync.completed) + batch.length;
                }
                this.ensMap = ensMap;
                await db0.cache.put({ objectName: 'ensMap', object: ensMap }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });

                for (const [address, ensName] of Object.entries(ensMap)) {
                  if (address in this.addresses) {
                    if (this.addresses[address].ensName != ensName) {
                      Vue.set(this.addresses[address], 'ensName', ensName);
                    }
                  } else {
                    Vue.set(this.addresses, address, {
                      address: address,
                      type: address == this.coinbase ? "eoa" : null,
                      mine: address == this.coinbase ? true : false,
                      ensName: ensName,
                      group: null,
                      name: null,
                      tags: [],
                      notes: null,
                      contract: {
                        name: null,
                        symbol: null,
                      },
                    });
                  }
                }
                // console.log(JSON.stringify(this.addresses));
                await db0.cache.put({ objectName: 'addresses', object: this.addresses }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "compute") {
                console.log("compute: " + JSON.stringify(Object.keys(this.selectedTxs)));
                for (let txHash of Object.keys(this.selectedTxs)) {
                  const txItem = this.txHashes[txHash];
                  // console.log(JSON.stringify(txItem, null, 2));
                  parseTx(txItem, provider);
                }
              }

              if (action == "computeAddresses") {
                console.log("computeAddresses");
                this.sync.completed = 0;
                const exclude = []; // ["0x5c40eF6f527f4FbA68368774E6130cE6515123f2", "0x755cdba6AE4F479f7164792B318b2a06c759833B", "0x5F0281910Af44bFb5fC7e86A404d0304B0e042F1", "0xe36f573DbeCDdBbcb72dD6270aF7978963F4C2D3", "0x60E112d4E585bba817Dc513bF9a03cd9b5A46Fc9", "0xcAFFa1d66eaE19887319ab9AECA5bd9aEB9D2DDE"];
                const addresses = Object.keys(this.selectedAddresses);
                // const addresses = Object.keys(this.addresses).filter(e => !exclude.includes(e));
                // console.log("addresses: " + JSON.stringify(addresses));
                this.sync.total = addresses.length;
                this.sync.section = "Addresses";

                const SPECIALS = {
                  "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85": {
                    mask: MASK_ISERC721,
                    type: "erc721",
                    symbol: "ENS",
                    name: "Ethereum Name Service",
                  },
                  "0xB22c1C159d12461EA124b0deb4b5b93020E6Ad16": {
                    mask: MASK_ISCONTRACT,
                    type: "contract",
                    symbol: "ENS",
                    name: "Old ETH Registrar Controller 2",
                  },
                  "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413": {
                    mask: MASK_ISERC20,
                    type: "erc20",
                    symbol: "DAO",
                    name: "The DAO",
                  },
                  "0xBf4eD7b27F1d666546E30D74d50d173d20bca754": {
                    mask: MASK_ISERC20,
                    type: "erc20",
                    symbol: "WithdrawDAO",
                    name: "WithdrawDAO",
                  },
                };

                for (let i = 0; i < addresses.length & !this.sync.halt; i++) {
                  const address = addresses[i];
                  console.log("address: " + JSON.stringify(address));

                  let mask = null;
                  let type = null;
                  let symbol = null;
                  let name = null;

                  if (address in SPECIALS) {
                    mask = SPECIALS[address].mask;
                    type = SPECIALS[address].type;
                    symbol = SPECIALS[address].symbol;
                    name = SPECIALS[address].name;
                    console.log("SPECIAL " + address + " - mask: " + mask + ", type: " + type + ", symbol: " + symbol + ", name: " + name);
                  } else {
                    try {
                      const tokenInfos = await erc721Helper.tokenInfo([address], { gasLimit: 100000000 });
                      for (let i = 0; i < tokenInfos[0].length; i++) {
                        const mask = tokenInfos[0][i].toNumber();
                        const symbol = tokenInfos[1][i];
                        const name = tokenInfos[2][i];
                      }
                      console.log("tokenInfo OK " + address + " - mask: " + mask + ", type: " + type + ", symbol: " + symbol + ", name: " + name);
                    } catch (e) {
                      console.log("tokenInfo ERROR - address: " + address + ", message: " + e.message);
                    }
                  }

                  if ((mask & MASK_ISEOA) == MASK_ISEOA) {
                    Vue.set(this.addresses[address], "type", "eoa");
                  } else if ((mask & MASK_ISERC721) == MASK_ISERC721) {
                    console.log("mask: erc721");
                    Vue.set(this.addresses[address], "type", "erc721");
                    Vue.set(this.addresses[address], "name", symbol + ': ' + name);
                    Vue.set(this.addresses[address], "contract", { name, symbol });
                  } else if ((mask & MASK_ISERC20) == MASK_ISERC20) {
                    console.log("mask: erc20");
                    Vue.set(this.addresses[address], "type", "erc20");
                    Vue.set(this.addresses[address], "name", symbol + ': ' + name);
                    Vue.set(this.addresses[address], "contract", { name, symbol });
                  } else if ((mask & MASK_ISCONTRACT) == MASK_ISCONTRACT) {
                    console.log("mask: contract");
                    Vue.set(this.addresses[address], "type", "contract");
                    if (symbol && symbol.length > 0 || name && name.length > 0) {
                      Vue.set(this.addresses[address], "name", symbol + ': ' + name);
                      Vue.set(this.addresses[address], "contract", { name, symbol });
                    }
                  }

                  this.sync.completed++;

                  // try {
                  //   const tokenInfos = await erc721Helper.tokenInfo([address], { gasLimit: 100000000 });
                  //   console.log("tokenInfos: " + JSON.stringify(tokenInfos));
                  //   for (let i = 0; i < tokenInfos[0].length; i++) {
                  //     // const mask = ethers.BigNumber.from(tokenInfos[0][i]).toString();
                  //     const mask = tokenInfos[0][i].toNumber();
                  //     const symbol = tokenInfos[1][i];
                  //     const name = tokenInfos[2][i];
                  //     console.log("mask: " + JSON.stringify(mask));
                  //     if ((mask & MASK_ISEOA) == MASK_ISEOA) {
                  //       Vue.set(this.addresses[address], "type", "eoa");
                  //     } else if ((mask & MASK_ISERC721) == MASK_ISERC721) {
                  //       console.log("mask: erc721");
                  //       Vue.set(this.addresses[address], "type", "erc721");
                  //       Vue.set(this.addresses[address], "name", symbol + ': ' + name);
                  //       Vue.set(this.addresses[address], "contract", { name, symbol });
                  //     } else if ((mask & MASK_ISERC20) == MASK_ISERC20) {
                  //       console.log("mask: erc20");
                  //       Vue.set(this.addresses[address], "type", "erc20");
                  //       Vue.set(this.addresses[address], "name", symbol + ': ' + name);
                  //       Vue.set(this.addresses[address], "contract", { name, symbol });
                  //     } else if ((mask & MASK_ISCONTRACT) == MASK_ISCONTRACT) {
                  //       console.log("mask: contract");
                  //       Vue.set(this.addresses[address], "type", "contract");
                  //     }
                  //     if (mask > 0) {
                  //   //     const totalSupply = ethers.BigNumber.from(tokenInfos[3][i]).toString();
                  //   //     tokenContracts[contractAddresses[i].toLowerCase()] = { mask, symbol, name, totalSupply };
                  //     }
                  //   }
                  // } catch (e) {
                  //   console.log("error: " + e.message);
                  // }

                  // this.sync.completed++;
                  // const tokenContracts = {};
                  // for (let i = 0; i < tokenInfos[0].length; i++) {
                  //   const mask = ethers.BigNumber.from(tokenInfos[0][i]).toString();
                  //   if (mask > 0) {
                  //     const symbol = tokenInfos[1][i];
                  //     const name = tokenInfos[2][i];
                  //     const totalSupply = ethers.BigNumber.from(tokenInfos[3][i]).toString();
                  //     tokenContracts[contractAddresses[i].toLowerCase()] = { mask, symbol, name, totalSupply };
                  //   }
                  // }
                }
                // console.log(JSON.stringify(this.addresses));
                await db0.cache.put({ objectName: 'addresses', object: this.addresses }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              db0.close();
              this.sync.section = null;
              this.sync.halt = false;
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          if ('coinbase' in localStorage) {
            this.coinbase = localStorage.coinbase;
          }
          if ('selectedAddresses' in localStorage) {
            this.selectedAddresses = JSON.parse(localStorage.selectedAddresses);
          }
          if ('selectedTxs' in localStorage) {
            this.selectedTxs = JSON.parse(localStorage.selectedTxs);
          }
          if ('settings' in localStorage) {
            // console.log("mounted - before - this.settings: " + JSON.stringify(this.settings, null, 2));
            // console.log("mounted - before - localStorage.settings: " + localStorage.settings);
            this.settings = { ...this.settings, ...JSON.parse(localStorage.settings) };

            if (this.settings.txs.currentPage > 1) {
              this.settings.txs.currentPage = 1;
            }
            if (this.settings.addressTable.currentPage > 1) {
              this.settings.addressTable.currentPage = 1;
            }
            if (!('addressTypeFilter' in this.settings.addressTable)) {
              console.log("Adding addressTypeFilter");
              this.settings.addressTable.addressTypeFilter = null;
            }
            if (!('searchAddresses' in this.settings.addressTable)) {
              console.log("Adding settings.addressTable.searchAddresses");
              this.settings.addressTable.searchAddresses = null;
            }
            if (!('addressMineFilter' in this.settings.addressTable)) {
              console.log("Adding addressMineFilter");
              this.settings.addressTable.addressMineFilter = null;
            }
            if (!('showDetails' in this.settings.addressTable)) {
              console.log("Adding addressTable.showDetails");
              this.settings.addressTable.showDetails = {};
            }
            if (!('searchTxs' in this.settings.txs)) {
              console.log("Adding settings.txs.searchTxs");
              this.settings.txs.searchTxs = null;
            }
            if (!('showDetails' in this.settings.txs)) {
              console.log("Adding txs.showDetails");
              this.settings.txs.showDetails = {};
            }
            if ('showAddresses' in this.settings) {
              console.log("Removing showAddresses");
              delete this.settings['showAddresses'];
            }
            if (!('etherscanAPIKey' in this.settings)) {
              console.log("Adding etherscanAPIKey");
              this.settings.etherscanAPIKey = null;
            }
            console.log("mounted - after: " + JSON.stringify(this.settings, null, 2));
          }
          (async() => {
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            const txHashes = await db0.cache.where("objectName").equals('txHashes').toArray();
            if (txHashes.length == 1) {
              this.txHashes = txHashes[0].object;
            }
            const ensMap = await db0.cache.where("objectName").equals('ensMap').toArray();
            if (ensMap.length == 1) {
              this.ensMap = ensMap[0].object;
            }
            const addresses = await db0.cache.where("objectName").equals('addresses').toArray();
            if (addresses.length == 1) {
              this.addresses = addresses[0].object;
              for (const [k, v] of Object.entries(this.addresses)) {
                if (!('type' in v)) {
                  v.type = null;
                }
                if (!('mine' in v)) {
                  v.mine = false;
                }
                // console.log("mount addresses: " + k + " => " + JSON.stringify(v));
              }
            }
            const importData = await db0.cache.where("objectName").equals('importData').toArray();
            if (importData.length == 1) {
              this.importData = importData[0].object;
              // console.log("mount this.importData: " + JSON.stringify(this.importData));
            }
            db0.close();
          })();
        },
      })
    </script>
  </body>
</html>
